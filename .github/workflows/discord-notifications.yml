name: Discord PR Notifications

on:
  pull_request:
    types:
      - opened
      - closed
      - reopened
      - ready_for_review
      - synchronize

permissions:
  contents: read
  pull-requests: read

jobs:
  notify-discord:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    # Skip this workflow if running on a fork (security: secrets not available to forks)
    if: github.event.pull_request.head.repo.full_name == github.repository

    steps:
      - name: Send PR Notification to Discord
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_PR_WEBHOOK_URL }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_URL: ${{ github.event.pull_request.html_url }}
          PR_AUTHOR: ${{ github.event.pull_request.user.login }}
          PR_ACTION: ${{ github.event.action }}
          PR_BODY: ${{ github.event.pull_request.body }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_BRANCH: ${{ github.event.pull_request.head.ref }}
          PR_BASE: ${{ github.event.pull_request.base.ref }}
          PR_STATE: ${{ github.event.pull_request.state }}
          PR_DRAFT: ${{ github.event.pull_request.draft }}
          PR_MERGED: ${{ github.event.pull_request.merged }}
          PR_LABELS: ${{ toJSON(github.event.pull_request.labels.*.name) }}
          PR_ASSIGNEES: ${{ toJSON(github.event.pull_request.assignees.*.login) }}
          PR_REVIEWERS: ${{ toJSON(github.event.pull_request.requested_reviewers.*.login) }}
          PR_SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          # Determine the color and action text based on PR action
          if [ "$PR_ACTION" = "opened" ]; then
            COLOR="2293317"  # Green
            ACTION_TEXT="opened a new pull request"
          elif [ "$PR_ACTION" = "closed" ] && [ "$PR_MERGED" = "true" ]; then
            COLOR="9056510"  # Purple
            ACTION_TEXT="merged the pull request"
          elif [ "$PR_ACTION" = "closed" ]; then
            COLOR="15680000" # Red
            ACTION_TEXT="closed the pull request"
          elif [ "$PR_ACTION" = "reopened" ]; then
            COLOR="3901635"  # Blue
            ACTION_TEXT="reopened the pull request"
          elif [ "$PR_ACTION" = "ready_for_review" ]; then
            COLOR="16098851" # Amber
            ACTION_TEXT="marked the pull request ready for review"
          elif [ "$PR_ACTION" = "synchronize" ]; then
            COLOR="1092106"  # Cyan
            ACTION_TEXT="pushed new commits to"
          else
            COLOR="7040640"  # Gray
            ACTION_TEXT="updated the pull request"
          fi

          # Determine status emoji and text
          if [ "$PR_DRAFT" = "true" ]; then
            STATUS="üìù Draft"
          elif [ "$PR_MERGED" = "true" ]; then
            STATUS="‚úÖ Merged"
          elif [ "$PR_STATE" = "open" ]; then
            STATUS="üîÑ Open"
          else
            STATUS="‚ùå Closed"
          fi

          # Truncate body if too long
          if [ ${#PR_BODY} -gt 300 ]; then
            DESCRIPTION="${PR_BODY:0:297}..."
          else
            DESCRIPTION="$PR_BODY"
          fi

          # If body is empty
          if [ -z "$DESCRIPTION" ]; then
            DESCRIPTION="No description provided."
          fi

          # Format labels
          LABELS_JSON=$(echo "$PR_LABELS" | jq -r 'join(", ")')
          if [ "$LABELS_JSON" = "" ] || [ "$LABELS_JSON" = "null" ]; then
            LABELS_DISPLAY="none"
          else
            LABELS_DISPLAY="$LABELS_JSON"
          fi

          # Format reviewers
          REVIEWERS_JSON=$(echo "$PR_REVIEWERS" | jq -r 'map("@" + .) | join(", ")')
          if [ "$REVIEWERS_JSON" = "" ] || [ "$REVIEWERS_JSON" = "null" ]; then
            REVIEWERS_DISPLAY="none"
          else
            REVIEWERS_DISPLAY="$REVIEWERS_JSON"
          fi

          # Format assignees
          ASSIGNEES_JSON=$(echo "$PR_ASSIGNEES" | jq -r 'map("@" + .) | join(", ")')
          if [ "$ASSIGNEES_JSON" = "" ] || [ "$ASSIGNEES_JSON" = "null" ]; then
            ASSIGNEES_DISPLAY="none"
          else
            ASSIGNEES_DISPLAY="$ASSIGNEES_JSON"
          fi

          # Get URLs
          COMPARE_URL="https://github.com/${{ github.repository }}/pull/$PR_NUMBER/files"
          CHECKS_URL="https://github.com/${{ github.repository }}/pull/$PR_NUMBER/checks"

          # Generate unique message ID for deduplication
          MESSAGE_ID="pr-$PR_NUMBER-$PR_ACTION-${PR_SHA:0:7}"

          # Format title with repo name
          FULL_TITLE="[bettergov] PR #$PR_NUMBER ¬∑ $PR_TITLE"

          # Create JSON payload
          cat <<EOF > payload.json
          {
            "username": "BetterGov GitHub Bot",
            "avatar_url": "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png",
            "embeds": [
              {
                "title": "$FULL_TITLE",
                "description": "$DESCRIPTION",
                "url": "$PR_URL",
                "color": $COLOR,
                "author": {
                  "name": "$PR_AUTHOR $ACTION_TEXT",
                  "icon_url": "https://github.com/$PR_AUTHOR.png",
                  "url": "https://github.com/$PR_AUTHOR"
                },
                "fields": [
                  {
                    "name": "üì¶ Repository",
                    "value": "[${{ github.repository }}](https://github.com/${{ github.repository }})",
                    "inline": true
                  },
                  {
                    "name": "üîÄ Branch",
                    "value": "\`$PR_BRANCH\` ‚Üí \`$PR_BASE\`",
                    "inline": true
                  },
                  {
                    "name": "üìä Status",
                    "value": "$STATUS",
                    "inline": true
                  },
                  {
                    "name": "üè∑Ô∏è Labels",
                    "value": "$LABELS_DISPLAY",
                    "inline": true
                  },
                  {
                    "name": "üë• Reviewers",
                    "value": "$REVIEWERS_DISPLAY",
                    "inline": true
                  },
                  {
                    "name": "üë§ Assignees",
                    "value": "$ASSIGNEES_DISPLAY",
                    "inline": true
                  },
                  {
                    "name": "üîó Links",
                    "value": "[View PR]($PR_URL) ‚Ä¢ [Diff]($COMPARE_URL) ‚Ä¢ [Checks]($CHECKS_URL)",
                    "inline": false
                  }
                ],
                "footer": {
                  "text": "BetterGov.ph ‚Ä¢ GitHub ‚Ä¢ $MESSAGE_ID",
                  "icon_url": "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png"
                },
                "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)"
              }
            ]
          }
          EOF

          # Send to Discord with retry logic
          MAX_RETRIES=3
          RETRY_DELAY=2

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i of $MAX_RETRIES: Sending notification to Discord..."

            if curl -X POST $DISCORD_WEBHOOK \
              -H "Content-Type: application/json" \
              -H "X-Message-ID: $MESSAGE_ID" \
              -d @payload.json \
              --fail-with-body \
              --max-time 10 \
              --retry 2 \
              --retry-delay 1; then
              echo "‚úÖ Notification sent successfully"
              exit 0
            else
              echo "‚ö†Ô∏è Attempt $i failed"
              if [ $i -lt $MAX_RETRIES ]; then
                echo "Retrying in $RETRY_DELAY seconds..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))  # Exponential backoff
              fi
            fi
          done

          echo "‚ùå Failed to send notification after $MAX_RETRIES attempts"
          exit 1